This folder demonstrates the effect of our phase 4 dataflow optimizations on a
quicksort partition function. The source code is in `.original.dcf` (taken from
`16-qsort.dcf` of the phase 3 private test case).

The initial non-SSA form IR generated by the semantic checker is in
`0.after-semantic-check.ir` (124 lines), after which several optimization steps are
performed:

1. `1.after-ssa-conversion.ir`: The SSA construction algorithm is applied to
   convert the non-SSA IR into SSA form. Phi instructions are inserted. (114 lines)
2. `2.after-dce.ir`: The dead code elimination pass eliminates dead code. In
   this case there wasn't much dead code in the original decaf source but the
   semantic checker inserted redundant initialization instructions for local
   variables. These redundant initializations are removed here. (108 lines; -6 lines)
3. `3.after-dce-cp.ir`: The copy propagation pass eliminates the many copies the
   SSA construction algorithm inserts. (83 lines; -25 lines)
4. `4.after-dce-cp-cse.ir`: The common subexpression elimination pass here
   eliminates common subexpressions. There wasn't much common subexpressions in the
   original code to begin with, but there were quite a few common constants (such
   as 0 and 1). The semantic checker dully emits a `load_const` instruction
   whenever it sees a constant in the AST. In this pass, these duplicate
   `load_const`s are eliminated. (75 lines; -8 lines)
5. `5.after-ssa-destruction.ir`: Before emitting assembly, we destruct the SSA
   form and removes all phi instructions. This bloats the code a bit and we plan
   to address that with register allocation in phase 5. (98 lines; +23 lines)

We can see that even without a contrived code sample, all three dataflow
optimizations are able to optimize away some IR instructions generated from a
normal code snippet.
